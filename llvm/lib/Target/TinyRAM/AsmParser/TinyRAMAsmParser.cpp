//===-- TinyRAMAsmParser.cpp - Parse TinyRAM assembly to MCInst instructions
//----===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "MCTargetDesc/TinyRAMInstPrinter.h"
#include "MCTargetDesc/TinyRAMMCTargetDesc.h"
#include "TargetInfo/TinyRAMTargetInfo.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/StringSwitch.h"
#include "llvm/MC/MCContext.h"
#include "llvm/MC/MCExpr.h"
#include "llvm/MC/MCInst.h"
#include "llvm/MC/MCParser/MCAsmLexer.h"
#include "llvm/MC/MCParser/MCAsmParser.h"
#include "llvm/MC/MCParser/MCParsedAsmOperand.h"
#include "llvm/MC/MCParser/MCTargetAsmParser.h"
#include "llvm/MC/MCStreamer.h"
#include "llvm/MC/MCSubtargetInfo.h"
#include "llvm/MC/MCSymbol.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/SMLoc.h"
#include "llvm/Support/raw_ostream.h"
#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <memory>

using namespace llvm;

// Auto-generated by TableGen
static unsigned MatchRegisterName(StringRef Name);

namespace {

// Instances of this class represented a parsed machine instruction
class TinyRAMOperand : public MCParsedAsmOperand {
  enum OperandKind {
    // KindInvalid,
    OpKind_Token,
    OpKind_Reg,
    OpKind_Imm,
  };

  OperandKind Kind;
  SMLoc StartLoc, EndLoc;

  // A string of length Length, starting at Data.
  struct TokenOp {
    const char *Data;
    unsigned Length;
  };

  struct RegOp {
    unsigned RegNo;
  };

  union {
    TokenOp Token;
    RegOp Reg;
    const MCExpr *Imm;
  };

  void addExpr(MCInst &Inst, const MCExpr *Expr) const {
    // Add as immediates when possible.  Null MCExpr = 0.
    if (!Expr)
      Inst.addOperand(MCOperand::createImm(0));
    else if (auto *CE = dyn_cast<MCConstantExpr>(Expr))
      Inst.addOperand(MCOperand::createImm(CE->getValue()));
    else
      Inst.addOperand(MCOperand::createExpr(Expr));
  }

public:
  TinyRAMOperand(OperandKind kind, SMLoc startLoc, SMLoc endLoc) : Kind(kind), StartLoc(startLoc), EndLoc(endLoc) {}

  // getStartLoc - Gets location of the first token of this operand
  SMLoc getStartLoc() const override {
    return StartLoc;
  }

  // getEndLoc - Gets location of the last token of this operand
  SMLoc getEndLoc() const override {
    return EndLoc;
  }

  bool isReg() const override {
    return Kind == OpKind_Reg;
  }

  unsigned getReg() const override {
    assert(isReg() && "Invalid type access!");
    return Reg.RegNo;
  }

  bool isImm() const override {
    return Kind == OpKind_Imm;
  }

  const MCExpr *getImm() const {
    assert(isImm() && "Invalid type access!");
    return Imm;
  }

  bool isMem() const override {
    return false;
  }

  bool isToken() const override {
    return Kind == OpKind_Token;
  }

  StringRef getToken() const {
    assert(isToken() && "Not a token");
    return StringRef(Token.Data, Token.Length);
  }

  static std::unique_ptr<TinyRAMOperand> createToken(StringRef Str, SMLoc Loc) {
    auto Op = std::make_unique<TinyRAMOperand>(OpKind_Token, Loc, Loc);
    Op->Token.Data = Str.data();
    Op->Token.Length = Str.size();
    return Op;
  }

  static std::unique_ptr<TinyRAMOperand> createReg(unsigned Num, SMLoc StartLoc, SMLoc EndLoc) {
    auto Op = std::make_unique<TinyRAMOperand>(OpKind_Reg, StartLoc, EndLoc);
    Op->Reg.RegNo = Num;
    return Op;
  }

  static std::unique_ptr<TinyRAMOperand> createImm(const MCExpr *Expr, SMLoc StartLoc, SMLoc EndLoc) {
    auto Op = std::make_unique<TinyRAMOperand>(OpKind_Imm, StartLoc, EndLoc);
    Op->Imm = Expr;
    return Op;
  }

  // Used by the TableGen code to add particular types of operand
  // to an instruction.
  void addRegOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands");
    Inst.addOperand(MCOperand::createReg(getReg()));
  }

  void addImmOperands(MCInst &Inst, unsigned N) const {
    assert(N == 1 && "Invalid number of operands");
    addExpr(Inst, getImm());
  }

  void print(raw_ostream &OS) const override {
    switch (Kind) {
    case OpKind_Imm:
      OS << "Imm: " << getImm() << "\n";
      break;
    case OpKind_Token:
      OS << "Token: " << getToken() << "\n";
      break;
    case OpKind_Reg:
      OS << "Reg: %r" << /*getReg() <<*/ "\n";
      break;
    }
  }
};

class TinyRAMAsmParser : public MCTargetAsmParser {
// Auto-generated instruction matching functions
#define GET_ASSEMBLER_HEADER
#include "TinyRAMGenAsmMatcher.inc"

  bool ParseDirective(AsmToken DirectiveID) override;

  bool ParseInstruction(ParseInstructionInfo &Info, StringRef Name, SMLoc NameLoc, OperandVector &Operands) override;

  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;
  bool ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc, bool RestoreOnFailure);
  OperandMatchResultTy tryParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) override;

  bool parseOperand(OperandVector &Operands, StringRef Mnemonic);

  bool MatchAndEmitInstruction(
      SMLoc IdLoc,
      unsigned &Opcode,
      OperandVector &Operands,
      MCStreamer &Out,
      uint64_t &ErrorInfo,
      bool MatchingInlineAsm) override;

public:
  TinyRAMAsmParser(
      const MCSubtargetInfo &STI,
      MCAsmParser &Parser,
      const MCInstrInfo &MII,
      const MCTargetOptions &Options)
      : MCTargetAsmParser(Options, STI, MII), Parser(Parser), Lexer(Parser.getLexer()), SubtargetInfo(STI) {
    setAvailableFeatures(ComputeAvailableFeatures(SubtargetInfo.getFeatureBits()));
  }

private:
  MCAsmParser &Parser;
  MCAsmLexer &Lexer;

  const MCSubtargetInfo &SubtargetInfo;
};

} // end anonymous namespace

#define GET_REGISTER_MATCHER
#define GET_SUBTARGET_FEATURE_NAME
#define GET_MATCHER_IMPLEMENTATION
#define GET_MNEMONIC_SPELL_CHECKER
#include "TinyRAMGenAsmMatcher.inc"

bool TinyRAMAsmParser::ParseDirective(AsmToken DirectiveID) {
  return true;
}

bool TinyRAMAsmParser::ParseInstruction(
    ParseInstructionInfo &Info,
    StringRef Name,
    SMLoc NameLoc,
    OperandVector &Operands) {
  // First operand in MCInst is instruction mnemonic.
  Operands.push_back(TinyRAMOperand::createToken(Name, NameLoc));

  // Read the remaining operands.
  if (getLexer().isNot(AsmToken::EndOfStatement)) {
    // Read the first operand.
    if (parseOperand(Operands, Name)) {
      return true;
    }

    // Read any subsequent operands.
    while (getLexer().is(AsmToken::Comma)) {
      Parser.Lex();
      if (parseOperand(Operands, Name)) {
        return true;
      }
    }
    if (getLexer().isNot(AsmToken::EndOfStatement)) {
      SMLoc Loc = getLexer().getLoc();
      return Error(Loc, "unexpected token in argument list");
    }
  }

  // Consume the EndOfStatement.
  Parser.Lex();
  return false;
}

bool TinyRAMAsmParser::parseOperand(OperandVector &Operands, StringRef Mnemonic) {
  // Check if it is a register.
  if (Lexer.is(AsmToken::Percent)) {
    unsigned RegNo;
    SMLoc StartLoc, EndLoc;
    if (ParseRegister(RegNo, StartLoc, EndLoc))
      return true;
    Operands.push_back(TinyRAMOperand::createReg(RegNo, StartLoc, EndLoc));
    return false;
  }

  // Could be immediate or address.
  if (Lexer.is(AsmToken::Integer)) {
    SMLoc StartLoc = Parser.getTok().getLoc();
    const MCExpr *Expr;
    if (Parser.parseExpression(Expr))
      return true;
    SMLoc EndLoc = Parser.getTok().getLoc();
    Operands.push_back(TinyRAMOperand::createImm(Expr, StartLoc, EndLoc));
    return false;
  }

  if (Lexer.is(AsmToken::Identifier)) {
    SMLoc StartLoc = Parser.getTok().getLoc();
    MCExpr const *Expr;
    if (!getParser().parseExpression(Expr)) {
#if 0
      llvm::dbgs() << "Expr (";
      Expr->print(llvm::dbgs(), nullptr);
      llvm::dbgs() << ")\n";
#endif
      SMLoc EndLoc = Parser.getTok().getLoc();
      Operands.push_back(TinyRAMOperand::createImm(Expr, StartLoc, EndLoc));
      return false;
    }
  }
  llvm::dbgs() << "parseOperand failed (" << Mnemonic << ", " << Lexer.getKind() << ")\n";
  // Failure
  return true;
}

bool TinyRAMAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc, bool RestoreOnFailure) {
  StartLoc = Parser.getTok().getLoc();

  // Eat the '%' prefix.
  if (Parser.getTok().isNot(AsmToken::Percent))
    return Error(Parser.getTok().getLoc(), "register expected");
  const AsmToken &PercentTok = Parser.getTok();
  Parser.Lex();

  // Match the register
  if (Lexer.getKind() != AsmToken::Identifier || (RegNo = MatchRegisterName(Lexer.getTok().getIdentifier())) == 0) {
    if (RestoreOnFailure)
      Lexer.UnLex(PercentTok);
    return Error(StartLoc, "invalid register");
  }

  Parser.Lex(); // Eat identifier token
  EndLoc = Parser.getTok().getLoc();
  return false;
}

bool TinyRAMAsmParser::ParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) {
  return ParseRegister(RegNo, StartLoc, EndLoc, /*RestoreOnFailure=*/false);
}

OperandMatchResultTy TinyRAMAsmParser::tryParseRegister(unsigned &RegNo, SMLoc &StartLoc, SMLoc &EndLoc) {
  bool Result = ParseRegister(RegNo, StartLoc, EndLoc, /*RestoreOnFailure=*/true);
  bool PendingErrors = getParser().hasPendingError();
  getParser().clearPendingErrors();
  if (PendingErrors)
    return MatchOperand_ParseFail;
  if (Result)
    return MatchOperand_NoMatch;
  return MatchOperand_Success;
}

bool TinyRAMAsmParser::MatchAndEmitInstruction(
    SMLoc IdLoc,
    unsigned &Opcode,
    OperandVector &Operands,
    MCStreamer &Out,
    uint64_t &ErrorInfo,
    bool MatchingInlineAsm) {
  MCInst Inst;
  unsigned MatchResult;
  FeatureBitset MissingFeatures;
  MatchResult = MatchInstructionImpl(Operands, Inst, ErrorInfo, MissingFeatures, MatchingInlineAsm);
  switch (MatchResult) {
  case Match_Success:
    Inst.setLoc(IdLoc);
    Out.emitInstruction(Inst, getSTI());
    return false;
  case Match_MissingFeature:
    // Currently no features are implemented.
    return Error(IdLoc, "Instruction use requires option to be enabled");
  case Match_InvalidOperand: {
    SMLoc ErrorLoc = IdLoc;
    if (ErrorInfo != ~0U) {
      if (ErrorInfo >= Operands.size())
        return Error(IdLoc, "Too few operands for instruction");

      // TODO
      // ErrorLoc = ((TinyRAMOperand &)*Operands[ErrorInfo]).getStartLoc();
      if (ErrorLoc == SMLoc())
        ErrorLoc = IdLoc;
    }
    return Error(ErrorLoc, "Invalid operand for instruction");
  }
  case Match_MnemonicFail: {
    FeatureBitset FBS = ComputeAvailableFeatures(getSTI().getFeatureBits());
    TinyRAMOperand &Op = static_cast<TinyRAMOperand &>(*Operands[0]);
    std::string Suggestion = TinyRAMMnemonicSpellCheck(Op.getToken(), FBS, 0);
    return Error(IdLoc, "invalid instruction" + Suggestion/*,
                 Op.getLocRange()*/);
  }
  }
  llvm_unreachable("Unexpected match type");
}

extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeTinyRAMAsmParser() {
  RegisterMCAsmParser<TinyRAMAsmParser> x(getTheTinyRAMTarget());
}
