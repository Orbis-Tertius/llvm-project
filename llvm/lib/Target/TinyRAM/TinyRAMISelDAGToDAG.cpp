//===-- TinyRAMISelDAGToDAG.cpp - A dag to dag inst selector for TinyRAM --===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the TinyRAM target.
//
//===----------------------------------------------------------------------===//

#include "TinyRAM.h"
#include "TinyRAMTargetMachine.h"
#include "llvm/Analysis/AliasAnalysis.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/KnownBits.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

#define DEBUG_TYPE "tinyRAM-isel"

namespace {

class TinyRAMDAGToDAGISel : public SelectionDAGISel {
  const TinyRAMSubtarget *Subtarget;

  const TinyRAMTargetMachine &getTargetMachine() const {
    return static_cast<const TinyRAMTargetMachine &>(TM);
  }

  // Complex Pattern Selectors.
  bool SelectADDRspii(SDValue Addr, SDValue &Base, SDValue &Offset);

public:
  TinyRAMDAGToDAGISel(TinyRAMTargetMachine &TM, CodeGenOpt::Level OptLevel) : SelectionDAGISel(TM, OptLevel) {}

  // Override MachineFunctionPass.
  StringRef getPassName() const override {
    return "TinyRAM DAG->DAG Pattern Instruction Selection";
  }

  // Override SelectionDAGISel.
  void Select(SDNode *Node) override;

// Include the pieces autogenerated from the target description.
#include "TinyRAMGenDAGISel.inc"
};
} // end anonymous namespace

FunctionPass *llvm::createTinyRAMISelDag(TinyRAMTargetMachine &TM, CodeGenOpt::Level OptLevel) {
  return new TinyRAMDAGToDAGISel(TM, OptLevel);
}

void TinyRAMDAGToDAGISel::Select(SDNode *Node) {
  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.

  // Select the default instruction.
  SelectCode(Node);
}

bool TinyRAMDAGToDAGISel::SelectADDRspii(SDValue Addr, SDValue &Base, SDValue &Offset) {
  FrameIndexSDNode *FIN = nullptr;
  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
    return true;
  }
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN = nullptr;
    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) && (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) &&
        (CN->getSExtValue() % 4 == 0 && CN->getSExtValue() >= 0)) {
      // Constant positive word offset from frame index
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
      Offset = CurDAG->getTargetConstant(CN->getSExtValue(), SDLoc(Addr), MVT::i32);
      return true;
    }
  }
  return false;
}
